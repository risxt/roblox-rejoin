#!/usr/bin/env python3
"""
Roblox Auto-Reconnect Tool for Termux (Cloud Phone)
Monitors multiple Roblox instances and auto-reconnects to Private Server on crash.

Requirements:
- Android Cloud Phone (Redfinger, VMOS, etc.)
- Root access enabled
- Termux with tsu package

Author: Generated by AI
Version: 1.0.0
"""

import subprocess
import re
import time
import signal
import sys
import json
import os
from typing import Optional, Tuple, List
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Config:
    """Configuration data class"""
    packages: List[str]
    place_id: str
    link_code: str
    check_interval: int = 5
    launch_delay: int = 30
    debug_mode: bool = False


class Colors:
    """ANSI color codes for terminal output"""
    RESET = "\033[0m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"


class RobloxReconnect:
    """Main controller for Roblox auto-reconnect functionality"""
    
    CONFIG_FILE = "reconnect_config.json"
    
    def __init__(self):
        self.config: Optional[Config] = None
        self.running = False
        self.debug_mode = False
        self.stats = {pkg: {"crashes": 0, "last_crash": None} for pkg in []}
        
    def print_banner(self):
        """Display application banner"""
        banner = f"""
{Colors.CYAN}{Colors.BOLD}
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë     üéÆ Roblox Auto-Reconnect Tool v1.0                    ‚ïë
‚ïë     For Termux (Cloud Phone)                              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ‚Ä¢ Multi-instance monitoring                              ‚ïë
‚ïë  ‚Ä¢ Auto-reconnect to Private Server                       ‚ïë
‚ïë  ‚Ä¢ Root-based process detection                           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
{Colors.RESET}"""
        print(banner)
    
    def log(self, message: str, level: str = "INFO"):
        """Print formatted log message with timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        colors = {
            "INFO": Colors.BLUE,
            "SUCCESS": Colors.GREEN,
            "WARNING": Colors.YELLOW,
            "ERROR": Colors.RED,
            "CRASH": Colors.RED + Colors.BOLD,
        }
        color = colors.get(level, Colors.RESET)
        print(f"{Colors.CYAN}[{timestamp}]{Colors.RESET} {color}[{level}]{Colors.RESET} {message}")
    
    def run_root_command(self, command: str) -> Tuple[bool, str]:
        """Execute command with root privileges"""
        # Try su first (more universal), then tsu (Termux specific)
        for root_cmd in ["su -c", "tsu -c"]:
            try:
                result = subprocess.run(
                    f'{root_cmd} "{command}"',
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=15
                )
                # Check if command succeeded
                if result.returncode == 0 and result.stdout.strip():
                    return True, result.stdout.strip()
                elif result.returncode == 0:
                    return True, ""
            except FileNotFoundError:
                continue
            except subprocess.TimeoutExpired:
                return False, "Command timeout"
            except Exception:
                continue
        return False, "Root command not available"
    
    def check_root_access(self) -> bool:
        """Verify root access is available"""
        self.log("Checking root access...")
        success, output = self.run_root_command("id")
        if success and "uid=0" in output:
            self.log("Root access confirmed!", "SUCCESS")
            return True
        else:
            self.log("Root access not available! Please enable root.", "ERROR")
            return False
    
    def optimize_android(self):
        """Configure Android 12+ phantom process limits"""
        self.log("Configuring Android optimizations...")
        commands = [
            "device_config set_sync_disabled_for_tests persistent",
            "device_config put activity_manager max_phantom_processes 2147483647"
        ]
        for cmd in commands:
            success, _ = self.run_root_command(cmd)
            if not success:
                self.log(f"Warning: Could not run optimization: {cmd}", "WARNING")
        self.log("Android optimizations applied", "SUCCESS")
    
    def parse_private_server_url(self, url: str) -> Tuple[Optional[str], Optional[str]]:
        """
        Extract PlaceID and LinkCode from various URL formats
        
        Supports:
        - https://www.roblox.com/games/123456/GameName?privateServerLinkCode=XXXXX
        - https://roblox.com/share?code=XXX&type=Server
        - roblox://navigation/game?placeId=123456&launchData=XXXXX
        """
        url = url.strip()
        
        # Pattern for web URLs
        web_pattern = r'games/(\d+).*?privateServerLinkCode=([A-Za-z0-9_-]+)'
        # Pattern for deep links / launchData
        deep_pattern = r'placeId=(\d+).*?launchData=([A-Za-z0-9_-]+)'
        # Pattern for share links
        share_pattern = r'games/(\d+).*?code=([A-Za-z0-9_-]+)'
        
        for pattern in [web_pattern, deep_pattern, share_pattern]:
            match = re.search(pattern, url, re.IGNORECASE)
            if match:
                return match.group(1), match.group(2)
        
        return None, None
    
    def _check_pidof(self, package: str) -> bool:
        """Method 1: Check using pidof (fastest)"""
        success, output = self.run_root_command(f"pidof {package}")
        return success and bool(output.strip())
    
    def _check_ps_grep(self, package: str) -> bool:
        """Method 2: Check using ps | grep (more reliable)"""
        success, output = self.run_root_command(f"ps -A | grep {package}")
        return success and bool(output.strip())
    
    def _check_proc_filesystem(self, package: str) -> bool:
        """Method 3: Check /proc filesystem (most reliable for floating windows)"""
        # Read all /proc/*/cmdline files and search for package name
        command = f"for pid in /proc/[0-9]*; do cat $pid/cmdline 2>/dev/null | tr '\\0' ' ' | grep -q '{package}' && echo found && break; done"
        success, output = self.run_root_command(command)
        return success and "found" in output
    
    def _check_dumpsys_activity(self, package: str) -> bool:
        """Method 4: Check using dumpsys activity (ActivityManager)"""
        success, output = self.run_root_command(f"dumpsys activity processes | grep -i {package}")
        return success and bool(output.strip())
    
    def _check_window_focus(self, package: str) -> bool:
        """Method 5: Check if app is in current focus/active window"""
        success, output = self.run_root_command("dumpsys window windows | grep -E 'mCurrentFocus|mFocusedApp'")
        return success and package in output
    
    def is_process_running(self, package: str) -> bool:
        """
        Hybrid process detection with multiple fallback methods.
        Tries multiple methods to ensure reliable detection on Cloud Phones
        with floating windows.
        """
        methods = [
            ("pidof", self._check_pidof),
            ("ps|grep", self._check_ps_grep),
            ("/proc", self._check_proc_filesystem),
            ("dumpsys", self._check_dumpsys_activity),
            ("window", self._check_window_focus),
        ]
        
        for name, check_func in methods:
            result = check_func(package)
            if self.debug_mode:
                status = "‚úì" if result else "‚úó"
                self.log(f"  [{status}] {name}: {package}", "INFO" if result else "WARNING")
            if result:
                return True
        
        # All methods failed = process is not running
        return False
    
    def launch_roblox(self, package: str):
        """Launch Roblox with deep link to private server in freeform window mode"""
        uri = f"roblox://navigation/game?placeId={self.config.place_id}&launchData={self.config.link_code}"
        
        # Using am start with specific package and freeform window mode
        # --windowingMode 5 = Freeform/Floating window (Android 10+)
        command = f'am start -a android.intent.action.VIEW -d "{uri}" -p {package} --windowingMode 5'
        
        self.log(f"Launching {package} (freeform mode)...", "INFO")
        success, output = self.run_root_command(command)
        
        if success:
            self.log(f"‚úÖ Launched {package} successfully", "SUCCESS")
        else:
            self.log(f"‚ùå Failed to launch {package}: {output}", "ERROR")
        
        return success
    
    def load_config(self) -> bool:
        """Load configuration from file if exists"""
        if os.path.exists(self.CONFIG_FILE):
            try:
                with open(self.CONFIG_FILE, 'r') as f:
                    data = json.load(f)
                    self.config = Config(**data)
                    return True
            except Exception as e:
                self.log(f"Could not load config: {e}", "WARNING")
        return False
    
    def save_config(self):
        """Save current configuration to file"""
        if self.config:
            try:
                with open(self.CONFIG_FILE, 'w') as f:
                    json.dump(asdict(self.config), f, indent=2)
                self.log(f"Config saved to {self.CONFIG_FILE}", "SUCCESS")
            except Exception as e:
                self.log(f"Could not save config: {e}", "WARNING")
    
    def interactive_setup(self):
        """Interactive configuration prompts"""
        print(f"\n{Colors.BOLD}üìã Configuration Setup{Colors.RESET}\n")
        
        # Check for existing config
        if self.load_config():
            print(f"{Colors.GREEN}Found existing configuration:{Colors.RESET}")
            print(f"  ‚Ä¢ Place ID: {self.config.place_id}")
            print(f"  ‚Ä¢ Link Code: {self.config.link_code[:10]}...")
            print(f"  ‚Ä¢ Packages: {', '.join(self.config.packages)}")
            print()
            use_existing = input(f"{Colors.YELLOW}Use existing config? (y/n) [y]: {Colors.RESET}").strip().lower()
            if use_existing != 'n':
                return True
        
        # Get Private Server URL
        print(f"\n{Colors.CYAN}[1/4] Enter Private Server URL:{Colors.RESET}")
        print(f"      {Colors.YELLOW}(Supports: roblox.com/games/... or roblox://... URLs){Colors.RESET}")
        
        while True:
            url = input(f"  > ").strip()
            place_id, link_code = self.parse_private_server_url(url)
            
            if place_id and link_code:
                print(f"\n  {Colors.GREEN}‚úÖ Detected:{Colors.RESET}")
                print(f"     ‚Ä¢ Place ID: {place_id}")
                print(f"     ‚Ä¢ Link Code: {link_code}")
                break
            else:
                print(f"  {Colors.RED}‚ùå Could not parse URL. Please try again.{Colors.RESET}")
        
        # Get package names
        print(f"\n{Colors.CYAN}[2/4] Enter package names (comma separated):{Colors.RESET}")
        print(f"      {Colors.YELLOW}Example: com.roblox.client, com.roblox.client1{Colors.RESET}")
        
        while True:
            packages_input = input(f"  > ").strip()
            packages = [p.strip() for p in packages_input.split(',') if p.strip()]
            
            if packages:
                print(f"\n  {Colors.GREEN}‚úÖ {len(packages)} package(s) configured:{Colors.RESET}")
                for pkg in packages:
                    print(f"     ‚Ä¢ {pkg}")
                break
            else:
                print(f"  {Colors.RED}‚ùå Please enter at least one package name.{Colors.RESET}")
        
        # Get check interval
        print(f"\n{Colors.CYAN}[3/5] Check interval in seconds [default: 5]:{Colors.RESET}")
        interval_input = input(f"  > ").strip()
        check_interval = int(interval_input) if interval_input.isdigit() else 5
        
        # Get launch delay
        print(f"\n{Colors.CYAN}[4/5] Launch delay in seconds [default: 30]:{Colors.RESET}")
        print(f"      {Colors.YELLOW}(Time to wait after launching before next check){Colors.RESET}")
        delay_input = input(f"  > ").strip()
        launch_delay = int(delay_input) if delay_input.isdigit() else 30
        
        # Debug mode
        print(f"\n{Colors.CYAN}[5/5] Enable debug mode? (y/n) [n]:{Colors.RESET}")
        print(f"      {Colors.YELLOW}(Shows which detection method works){Colors.RESET}")
        debug_input = input(f"  > ").strip().lower()
        debug_mode = debug_input == 'y'
        
        # Create config
        self.config = Config(
            packages=packages,
            place_id=place_id,
            link_code=link_code,
            check_interval=check_interval,
            launch_delay=launch_delay,
            debug_mode=debug_mode
        )
        self.debug_mode = debug_mode
        
        # Initialize stats
        self.stats = {pkg: {"crashes": 0, "last_crash": None} for pkg in packages}
        
        # Save config
        save = input(f"\n{Colors.YELLOW}Save configuration for next time? (y/n) [y]: {Colors.RESET}").strip().lower()
        if save != 'n':
            self.save_config()
        
        return True
    
    def monitor_loop(self):
        """Main monitoring loop"""
        print(f"\n{Colors.GREEN}{Colors.BOLD}üöÄ Starting monitor...{Colors.RESET}")
        print(f"   Monitoring {len(self.config.packages)} instance(s)")
        print(f"   Check interval: {self.config.check_interval}s")
        print(f"   Press Ctrl+C to stop\n")
        print(f"{Colors.CYAN}{'='*60}{Colors.RESET}\n")
        
        self.running = True
        
        while self.running:
            for package in self.config.packages:
                if not self.running:
                    break
                    
                is_running = self.is_process_running(package)
                
                if is_running:
                    self.log(f"‚úì {package} is running", "INFO")
                else:
                    self.stats[package]["crashes"] += 1
                    self.stats[package]["last_crash"] = datetime.now().strftime("%H:%M:%S")
                    
                    self.log(f"üí• CRASH DETECTED: {package} (Total: {self.stats[package]['crashes']})", "CRASH")
                    
                    # Launch the app
                    if self.launch_roblox(package):
                        self.log(f"‚è≥ Waiting {self.config.launch_delay}s for app to load...", "INFO")
                        time.sleep(self.config.launch_delay)
            
            # Wait before next check cycle
            if self.running:
                time.sleep(self.config.check_interval)
    
    def graceful_shutdown(self, signum=None, frame=None):
        """Handle graceful shutdown on Ctrl+C"""
        print(f"\n\n{Colors.YELLOW}üõë Shutting down...{Colors.RESET}")
        self.running = False
        
        # Print stats
        print(f"\n{Colors.CYAN}üìä Session Statistics:{Colors.RESET}")
        for pkg, stats in self.stats.items():
            print(f"   ‚Ä¢ {pkg}: {stats['crashes']} crash(es)")
        
        print(f"\n{Colors.GREEN}Goodbye! üëã{Colors.RESET}\n")
        sys.exit(0)
    
    def run(self):
        """Main entry point"""
        # Setup signal handlers
        signal.signal(signal.SIGINT, self.graceful_shutdown)
        signal.signal(signal.SIGTERM, self.graceful_shutdown)
        
        # Display banner
        self.print_banner()
        
        # Check root access
        if not self.check_root_access():
            print(f"\n{Colors.RED}Please enable root access and try again.{Colors.RESET}")
            sys.exit(1)
        
        # Apply Android optimizations
        self.optimize_android()
        
        # Interactive setup
        if not self.interactive_setup():
            print(f"\n{Colors.RED}Setup cancelled.{Colors.RESET}")
            sys.exit(1)
        
        # Start monitoring
        try:
            self.monitor_loop()
        except KeyboardInterrupt:
            self.graceful_shutdown()


def main():
    """Script entry point"""
    tool = RobloxReconnect()
    tool.run()


if __name__ == "__main__":
    main()
